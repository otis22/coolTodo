# Task E6: Исправить перезапуск app контейнера

**Статус**: Open  
**Приоритет**: High  
**Оценка**: 0.5 дня

## Описание

App контейнер постоянно перезапускается. В логах видно, что он запускает интерактивную оболочку PHP (`php > Interactive shell`) вместо работы как сервис. Проблема в том, что `Dockerfile.dev` использует `php:8.3-cli` (CLI версия), а nginx ожидает PHP-FPM на порту 9000.

## Проблема

**Текущая ситуация**:
- Контейнер `cooltodo_app` в статусе `Restarting`
- В логах: `php > Interactive shell`
- Dockerfile.dev использует `php:8.3-cli` (не FPM)
- Nginx пытается подключиться к `app:9000` (PHP-FPM порт)
- В docker-compose.yml нет команды запуска для app контейнера

**Корневая причина**:
- Архитектурное несоответствие: CLI образ не может работать как FPM сервис
- Для dev окружения нужен PHP-FPM, но используется CLI образ

## Зависимости

- [x] A3: Настроить Docker окружение (Completed ✅)

## Требования

### Цель

Создать системное решение, которое работает в:
- **Dev окружении**: PHP-FPM для nginx + возможность выполнения CLI команд
- **CI workflow**: Только CLI (без веб-сервера)
- **Production**: PHP-FPM (уже есть в Dockerfile)

### Критерии приемки

✅ App контейнер работает стабильно (не перезапускается) в dev  
✅ PHP-FPM доступен для nginx на порту 9000  
✅ API endpoints работают через nginx  
✅ CLI команды (artisan, phpunit) работают через `./dev` скрипт  
✅ CI workflow не требует изменений (использует CLI напрямую)  
✅ Production конфигурация не затронута

## Системное решение

### Вариант 1: Создать отдельный Dockerfile.dev.fpm (Рекомендуется)

**Преимущества**:
- Четкое разделение: CLI для команд, FPM для веб-сервера
- Dev окружение работает как production (FPM + nginx)
- CI не затронут (использует PHP напрямую)

**Реализация**:
1. Создать `Dockerfile.dev.fpm` на базе `php:8.3-fpm`
2. Обновить `docker-compose.yml`: app использует `Dockerfile.dev.fpm`
3. Добавить команду запуска: `command: php-fpm`
4. Для CLI команд использовать `docker compose run --rm app php ...` (уже работает через `./dev`)

### Вариант 2: Использовать один образ с поддержкой обоих режимов

**Недостатки**: Более сложная конфигурация, смешивание ответственности

### Выбранный вариант: Вариант 1

## План выполнения

### Шаг 1: Создание Dockerfile.dev.fpm
- [ ] Создать `Dockerfile.dev.fpm` на базе `php:8.3-fpm`
- [ ] Скопировать установки из `Dockerfile.dev` (зависимости, Xdebug)
- [ ] Настроить рабочую директорию `/var/www/project/backend`
- [ ] Убедиться, что Xdebug работает в FPM режиме

### Шаг 2: Обновление docker-compose.yml
- [ ] Изменить `dockerfile: Dockerfile.dev` на `dockerfile: Dockerfile.dev.fpm` для сервиса `app`
- [ ] Добавить `command: php-fpm` для сервиса `app`
- [ ] Убедиться, что порт 9000 доступен для nginx
- [ ] Проверить, что `./dev` скрипт продолжает работать (использует `run --rm`)

### Шаг 3: Тестирование
- [ ] Проверить, что app контейнер не перезапускается
- [ ] Проверить, что PHP-FPM доступен на порту 9000
- [ ] Проверить, что CLI команды работают через `./dev`
- [ ] Проверить, что CI workflow не сломан (не использует docker-compose для тестов)

### Шаг 4: Документация
- [ ] Обновить документацию о структуре Docker образов
- [ ] Убедиться, что различия между dev и production понятны

## Прогресс

Создано: 2025-01-27  
Обновлено: 2025-01-27 (системный анализ)

