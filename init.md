# PROMPT: Генератор каркаса проекта для ИИ-агентов

## РОЛЬ

Ты — экспертный системный архитектор и менеджер проектов, управляющий ИИ. Твоя задача — сгенерировать полный, готовый к работе каркас проекта на основе предоставленных пользователем спецификаций. Этот каркас должен быть структурирован таким образом, чтобы автономные ИИ-агенты по разработке могли немедленно приступить к работе без дополнительных уточнений.

Ты должен создать всю необходимую документацию, структуру директорий, конфигурационные файлы и базовый код, следуя принципам **Extreme Programming (XP)**, **Test-Driven Development (TDD)** и **Puzzle-Driven Development (PDD)**, заложенным в методологии репозитория `SoundBlaster/ISOInspector`.

---

## ВХОДНЫЕ ДАННЫЕ (предоставляются пользователем)

### 1. Название проекта

`CoolTodo`

### 2. Описание проекта

`Веб-сервис для управления персональным списком задач (заметками, "todo"). 
Одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. 
Все изменения немедленно сохраняются на сервере для синхронизации между устройствами.`

### 3. Технологический стек

`PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x`

*Пример: Python, Django, PostgreSQL, Docker, React, Webpack*

### 4. Техническое задание (ТЗ)

`**Техническое задание на разработку веб-сервиса управления задачами (Todo Service)**

---

### 1. Введение

#### 1.1. Назначение документа
Настоящий документ содержит функциональные требования к веб-сервису для управления персональным списком задач (заметками, "todo"). Сервис должен быть доступен через веб-браузер и обеспечивать синхронизацию данных между различными устройствами пользователя за счет хранения всех операций на сервере.

#### 1.2. Описание продукта
Данный сервис представляет собой одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. Все изменения должны немедленно сохраняться на сервере. Основной упор делается на простоту, надежность и отзывчивость интерфейса.

---

### 2. Функциональные требования

#### 2.1. Управление задачами

**2.1.1. Создание новой задачи**
*   **Триггер:** Пользователь вводит текст в поле ввода и нажимает клавишу `Enter`.
*   **Требования:**
    *   Система должна создать новую задачу с введенным текстом.
    *   Новая задача по умолчанию получает статус "не выполнена" (`active`).
    *   Задача должна быть немедленно сохранена на сервере.
    *   Поле ввода должно быть очищено после создания задачи.

**2.1.2. Просмотр списка задач**
*   **Триггер:** Открытие приложения или выполнение любой операции, изменяющей список.
*   **Требования:**
    *   Система должна отображать список всех задач пользователя.
    *   Для каждой задачи должен отображаться ее текст и текущий статус.
    *   Список должен автоматически обновляться при любых изменениях (создание, редактирование, удаление, изменение статуса).

**2.1.3. Редактирование текста задачи**
*   **Триггер:** Пользователь дважды кликает по тексту существующей задачи.
*   **Требования:**
    *   Система должна перевести поле текста задачи в режим редактирования.
    *   Пользователь должен иметь возможность изменить текст.
    *   При нажатии клавиши `Enter` или потере полем фокуса (`blur`) система должна сохранить изменения на сервере и выйти из режима редактирования.
    *   При нажатии клавиши `Escape` система должна отменить редактирование, восстановив исходный текст, без сохранения на сервере.

**2.1.4. Изменение статуса задачи (выполнено/не выполнено)**
*   **Триггер:** Пользователь кликает на чекбокс слева от задачи.
*   **Требования:**
    *   При клике на чекбокс у невыполненной задачи система должна изменить ее статус на "выполнена" (`completed`).
    *   При клике на чекбокс у выполненной задачи система должна изменить ее статус на "не выполнена" (`active`).
    *   Изменение статуса должно быть немедленно сохранено на сервере.
    *   Визуальное отображение задачи (например, перечеркнутый текст) должно изменяться в соответствии с ее статусом.

**2.1.5. Удаление одной задачи**
*   **Триггер:** Пользователь наводит курсор на задачу и нажимает на кнопку "Удалить" (обычно значок `×`), которая появляется при наведении.
*   **Требования:**
    *   Система должна удалить соответствующую задачу.
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Задача должна быть удалена из интерфейса.

**2.1.6. Удаление всех выполненных задач**
*   **Триггер:** Пользователь нажимает на кнопку "Clear completed" ("Очистить выполненные").
*   **Требования:**
    *   Система должна удалить все задачи со статусом "выполнена" (`completed`).
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Соответствующие задачи должны быть удалены из интерфейса.

#### 2.2. Фильтрация и отображение

**2.2.1. Переключение между фильтрами**
*   **Триггер:** Пользователь кликает на один из элементов управления для фильтрации: "All", "Active", "Completed".
*   **Требования:**
    *   **All:** Система отображает все задачи (и `active`, и `completed`).
    *   **Active:** Система отображает только задачи со статусом "не выполнена" (`active`).
    *   **Completed:** Система отображает только задачи со статусом "выполнена" (`completed`).
    *   Сами задачи на сервере не изменяются. Фильтрация происходит на стороне клиента на основе актуальных данных, полученных с сервера.

#### 2.3. Вспомогательная информация

**2.3.1. Отображение количества невыполненных задач**
*   **Триггер:** Любое изменение в списке задач.
*   **Требования:**
    *   Система должна отображать текущее количество невыполненных задач (`active`).
    *   Текст должен быть в формате, например: "`<n> items left`" ("`<n> задач осталось`").

#### 2.4. Требования к данным и синхронизации

**2.4.1. Сохранение состояния на сервере**
*   Все операции, изменяющие данные (создание, редактирование текста, изменение статуса, удаление), должны немедленно инициировать запрос к серверу для сохранения изменений.
*   Клиентское приложение должно работать с актуальными данными, полученными с сервера.

**2.4.2. Целостность данных**
*   Каждая задача должна иметь на сервере уникальный идентификатор, присваиваемый при создании.
*   Сервер является единственным источником истины для состояния приложения.

**2.4.3. Обработка конфликтов и ошибок**
*   В случае ошибки сети или сервера при выполнении операции (например, сохранении новой задачи) система должна уведомить пользователя о невозможности выполнить действие.
*   Система должна предпринимать попытки повтора неудачных операций или предоставлять пользователю возможность повторить действие.

---

### 3. Заключение

Данный документ описывает базовый функционал веб-сервиса для управления задачами. Все требования являются функциональными и не накладывают ограничений на выбор технологий для реализации клиентской и серверной частей, за исключением обязательного требования о постоянном хранении данных на сервере и их синхронизации с клиентским интерфейсом.
`

*Пример: "Веб-приложение для управления задачами с аутентификацией пользователей, созданием/редактированием задач и установкой дедлайнов. API должен быть RESTful."*

### 5. Ключевые компоненты/модули

`backend/src/Domain/UseCases (бизнес-логика для управления задачами),
backend/src/Domain/Models (сущности Task, User),
backend/src/Infrastructure/Repositories (репозитории для работы с БД),
backend/src/Infrastructure/Http/Controllers (API контроллеры),
frontend/src/components/TodoList (компонент списка задач),
frontend/src/components/TodoItem (компонент отдельной задачи),
frontend/src/services/api (сервис для работы с backend API)`

*Пример: "backend/users, backend/tasks, frontend/src/components/Auth, frontend/src/components/TaskList"*

---

## ИНСТРУКЦИИ ПО ГЕНЕРАЦИИ

### ШАГ 1: Создай документацию для автономной работы ИИ-агента (директория `DOCS/`)

Создай следующие файлы. Их содержимое должно быть универсальным, но адаптированным под `CoolTodo`, `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x` и `backend/src/Domain/UseCases (бизнес-логика для управления задачами),
backend/src/Domain/Models (сущности Task, User),
backend/src/Infrastructure/Repositories (репозитории для работы с БД),
backend/src/Infrastructure/Http/Controllers (API контроллеры),
frontend/src/components/TodoList (компонент списка задач),
frontend/src/components/TodoItem (компонент отдельной задачи),
frontend/src/services/api (сервис для работы с backend API)`.

#### 1.1. `DOCS/RULES/01_PRD_Authoring.md`

Правила написания PRD (Product Requirements Document) для ИИ-агента. Документ должен содержать:

- **Цель**: Объяснить, как создавать самодостаточные, однозначные и машиночитаемые PRD.

- **Шестишаговый процесс**:
    1. Определить scope и намерение
    1. Декомпозировать в структурированный TODO план
    1. Обогатить каждую подзадачу метаданными (приоритет, оценка, инструменты, критерии приемки)
    1. Создать PRD-подобную секцию (функциональные/нефункциональные требования, edge cases)
    1. Применить правила контроля качества (избегать расплывчатого языка)
    1. Формат вывода: Markdown с таблицами

#### 1.2. `DOCS/RULES/02_TDD_XP_Workflow.md`

Описание рабочего процесса на основе TDD и XP. Документ должен содержать:

- **Миссия**: Ты — автономный инженерный агент, практикующий Extreme Programming с полным TDD.

- **Руководящие принципы**:
  - Outside-In Evolution: начинать с высокоуровневого поведения, двигаться к деталям
  - Always Green Main Branch: каждый коммит должен проходить сборку, тесты, CI
  - Test-First Mindset: нет production кода без предшествующего failing теста
  - Incremental Learning: уточнять архитектуру с помощью коротких циклов обратной связи
  - Automated Delivery: поддерживать CI/CD с самых ранних итераций

- **Обзор фаз**:
    1. Инициализация скелета (репозиторий, CI, метаданные пакета)
    1. Написание высокоуровневых acceptance-тестов
    1. Реализация Outside-In
    1. Цикл рефакторинга
    1. Готовность к развертыванию

#### 1.3. `DOCS/RULES/03_Next_Task_Selection.md`

Алгоритм выбора следующей задачи для ИИ-агента. Документ должен содержать:

- **Цель**: Обеспечить контролируемое, зависимо-осознанное продвижение по backlog.

- **Шаги выбора**:
    1. Перечислить кандидатов из TODO Workplan
    1. Фильтровать по готовности (зависимости удовлетворены)
    1. Приоритизировать (High > Medium > Low, затем самая ранняя фаза, затем наименьший ID)
    1. Проверка на здравый смысл (нет блокирующих рисков)
    1. Записать решение в `DOCS/INPROGRESS/`

#### 1.4. `DOCS/RULES/agent-system-prompt.md`

Системный промпт для ИИ-агента, работающего над этим проектом. Документ должен содержать:

- **Идентификация**: "Ты — ИИ Coding Agent, работающий в монорепозитории `CoolTodo` с компонентами: `backend/src/Domain/UseCases (бизнес-логика для управления задачами),
backend/src/Domain/Models (сущности Task, User),
backend/src/Infrastructure/Repositories (репозитории для работы с БД),
backend/src/Infrastructure/Http/Controllers (API контроллеры),
frontend/src/components/TodoList (компонент списка задач),
frontend/src/components/TodoItem (компонент отдельной задачи),
frontend/src/services/api (сервис для работы с backend API)`"

- **Цель**: Для каждой задачи/итерации:
    1. Реализовать наименьшее жизнеспособное изменение
    1. Распространить все публичные изменения API на зависимые компоненты
    1. Оставить точные PDD puzzles (@todo) и написать micro-PRD заметку в `DOCS/INPROGRESS/` для незавершенной работы

- **Core Loop** (8 шагов):
    1. Читать входные данные (todo.md, INPROGRESS/, git diff)
    1. Анализ влияния (если изменен публичный API → обновить все вызовы)
    1. Спроектировать минимальный PR (~150 строк)
    1. Реализовать (TDD, чистые функции)
    1. Распространить (обновить CLI/App если изменен Kit)
    1. Документировать (micro-PRD заметка, @todo puzzles)
    1. Проверка качества (сборка, тесты, линтинг)
    1. Выходные данные (код, тесты, INPROGRESS заметка, описание PR)

- **Формат PDD puzzle**:

   ```
   // @todo PDD:30min <описание>
   // Details: <где продолжить>
   ```

- **Шаблон Micro-PRD заметки**:

   ```markdown
   # <Short topic> — micro PRD
   
   ## Intent
   Одно предложение, описывающее единственный результат этого PR.
   
   ## Scope
   - Component1: <затронутые типы/функции>
   - Component2: <затронутые команды/флаги>
   
   ## Integration contract
   - Public API added/changed: <набросок сигнатуры>
   - Call sites updated: <файлы/команды>
   - Backward compat: <сохранена/deprecated/breaking>
   - Tests: <новые/обновленные тесты>
   
   ## Next puzzles
   - [ ] <маленькое продолжение 1>
   - [ ] <маленькое продолжение 2>
   
   ## Notes
   Build: <команда сборки и тестирования>
   ```

- **Когда изменяется публичный API**: Делать ВСЁ это:
  1. Обновить реализацию + docs комментарий
  2. Найти и обновить все call sites
  3. Предоставить shim или @deprecated когда возможно
  4. Добавить/скорректировать тесты во всех компонентах
  5. Запустить полную сборку workspace; исправить ВСЕ ошибки компиляции
  6. Написать micro-PRD заметку и оставить @todo для оставшейся работы

- **Архивирование задач**: При завершении задачи создать файл в `DOCS/TASK_ARCHIVE/[TaskID]_[TaskName]/` со следующими секциями:
  1. **Summary**: Краткое описание задачи
  2. **Source Requirements**: Ссылки на источники требований
  3. **Objectives**: Конкретные цели
  4. **Dependencies**: Зависимости от других задач
  5. **In-Scope / Out of Scope**: Границы задачи
  6. **Acceptance Criteria**: Критерии приемки
  7. **Implementation Notes**: Заметки по реализации
  8. **Lessons Learned**: **ОБЯЗАТЕЛЬНО** — что сработало, что не сработало, какие подходы были отвергнуты и почему
  9. **Immediate Next Steps**: Следующие шаги (если есть)

- **Обновление Assumption Log**: После каждой задачи, где были сделаны важные предположения или обнаружены неудачные подходы, **ОБЯЗАТЕЛЬНО** добавить запись в `DOCS/AI/Execution_Guide/05_Assumption_Log.md` с датой, ID задачи, описанием подхода, результатом и извлеченным уроком работы

- **Стиль коммитов/PR**:
  - Коммит: императив, с scope. Пример: `feat(api): add user authentication endpoint`
  - PR title: "Add user authentication endpoint (small)"
  - PR body: 3 пункта — Что изменилось, Почему, Как проверено

- **Guardrails**:
  - Никогда не скрывать failing compilation сужением scope
  - Предпочитать аддитивный API с defaults
  - Если задача охватывает >1 PR, убедиться, что первый PR можно безопасно смержить

---

### ШАГ 2: Создай руководство по выполнению проекта (директория `DOCS/AI/`)

Эти документы должны быть заполнены на основе входных данных пользователя.

#### 2.1. `DOCS/AI/Execution_Guide/01_Project_Scope.md`

Цели, результаты и ограничения проекта. Используй `CoolTodo` и `Веб-сервис для управления персональным списком задач (заметками, "todo"). 
Одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. 
Все изменения немедленно сохраняются на сервере для синхронизации между устройствами.`.

**Структура:**
- **Objective**: Описание цели проекта

- **Deliverables**: Список основных результатов (например, Core library, CLI tool, Web app)

- **Constraints**: Технические ограничения (версии языков, покрытие тестами, всегда зеленая main ветка)

#### 2.5. `DOCS/AI/Execution_Guide/05_Assumption_Log.md`

**ВАЖНО**: Создай журнал для отслеживания предположений, неудачных подходов и извлеченных уроков.

**Структура:**

```markdown
# Assumption Log

## Purpose

This log tracks assumptions made during development, failed approaches, and lessons learned to prevent repeating mistakes and inform future decisions.

## Log Entries

### Entry Template

| Date | Task ID | Assumption/Approach | Outcome | Lesson Learned | Alternative Taken |
|------|---------|---------------------|---------|----------------|-------------------|
| YYYY-MM-DD | [Task ID] | [What was tried] | [Success/Failure] | [Why it failed/succeeded] | [What was done instead] |

### Example Entry

| Date | Task ID | Assumption/Approach | Outcome | Lesson Learned | Alternative Taken |
|------|---------|---------------------|---------|----------------|-------------------|
| 2025-10-05 | A3 | Assumed JWT tokens could be stored in localStorage | Failed | Security vulnerability: XSS attacks can steal tokens | Switched to httpOnly cookies |

## Active Assumptions

(List current assumptions that need validation)

- [ ] Assumption 1: [Description]
- [ ] Assumption 2: [Description]
```

#### 2.2. `DOCS/AI/Execution_Guide/02_Product_Requirements.md`

Функциональные и нефункциональные требования. Используй `**Техническое задание на разработку веб-сервиса управления задачами (Todo Service)**

---

### 1. Введение

#### 1.1. Назначение документа
Настоящий документ содержит функциональные требования к веб-сервису для управления персональным списком задач (заметками, "todo"). Сервис должен быть доступен через веб-браузер и обеспечивать синхронизацию данных между различными устройствами пользователя за счет хранения всех операций на сервере.

#### 1.2. Описание продукта
Данный сервис представляет собой одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. Все изменения должны немедленно сохраняться на сервере. Основной упор делается на простоту, надежность и отзывчивость интерфейса.

---

### 2. Функциональные требования

#### 2.1. Управление задачами

**2.1.1. Создание новой задачи**
*   **Триггер:** Пользователь вводит текст в поле ввода и нажимает клавишу `Enter`.
*   **Требования:**
    *   Система должна создать новую задачу с введенным текстом.
    *   Новая задача по умолчанию получает статус "не выполнена" (`active`).
    *   Задача должна быть немедленно сохранена на сервере.
    *   Поле ввода должно быть очищено после создания задачи.

**2.1.2. Просмотр списка задач**
*   **Триггер:** Открытие приложения или выполнение любой операции, изменяющей список.
*   **Требования:**
    *   Система должна отображать список всех задач пользователя.
    *   Для каждой задачи должен отображаться ее текст и текущий статус.
    *   Список должен автоматически обновляться при любых изменениях (создание, редактирование, удаление, изменение статуса).

**2.1.3. Редактирование текста задачи**
*   **Триггер:** Пользователь дважды кликает по тексту существующей задачи.
*   **Требования:**
    *   Система должна перевести поле текста задачи в режим редактирования.
    *   Пользователь должен иметь возможность изменить текст.
    *   При нажатии клавиши `Enter` или потере полем фокуса (`blur`) система должна сохранить изменения на сервере и выйти из режима редактирования.
    *   При нажатии клавиши `Escape` система должна отменить редактирование, восстановив исходный текст, без сохранения на сервере.

**2.1.4. Изменение статуса задачи (выполнено/не выполнено)**
*   **Триггер:** Пользователь кликает на чекбокс слева от задачи.
*   **Требования:**
    *   При клике на чекбокс у невыполненной задачи система должна изменить ее статус на "выполнена" (`completed`).
    *   При клике на чекбокс у выполненной задачи система должна изменить ее статус на "не выполнена" (`active`).
    *   Изменение статуса должно быть немедленно сохранено на сервере.
    *   Визуальное отображение задачи (например, перечеркнутый текст) должно изменяться в соответствии с ее статусом.

**2.1.5. Удаление одной задачи**
*   **Триггер:** Пользователь наводит курсор на задачу и нажимает на кнопку "Удалить" (обычно значок `×`), которая появляется при наведении.
*   **Требования:**
    *   Система должна удалить соответствующую задачу.
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Задача должна быть удалена из интерфейса.

**2.1.6. Удаление всех выполненных задач**
*   **Триггер:** Пользователь нажимает на кнопку "Clear completed" ("Очистить выполненные").
*   **Требования:**
    *   Система должна удалить все задачи со статусом "выполнена" (`completed`).
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Соответствующие задачи должны быть удалены из интерфейса.

#### 2.2. Фильтрация и отображение

**2.2.1. Переключение между фильтрами**
*   **Триггер:** Пользователь кликает на один из элементов управления для фильтрации: "All", "Active", "Completed".
*   **Требования:**
    *   **All:** Система отображает все задачи (и `active`, и `completed`).
    *   **Active:** Система отображает только задачи со статусом "не выполнена" (`active`).
    *   **Completed:** Система отображает только задачи со статусом "выполнена" (`completed`).
    *   Сами задачи на сервере не изменяются. Фильтрация происходит на стороне клиента на основе актуальных данных, полученных с сервера.

#### 2.3. Вспомогательная информация

**2.3.1. Отображение количества невыполненных задач**
*   **Триггер:** Любое изменение в списке задач.
*   **Требования:**
    *   Система должна отображать текущее количество невыполненных задач (`active`).
    *   Текст должен быть в формате, например: "`<n> items left`" ("`<n> задач осталось`").

#### 2.4. Требования к данным и синхронизации

**2.4.1. Сохранение состояния на сервере**
*   Все операции, изменяющие данные (создание, редактирование текста, изменение статуса, удаление), должны немедленно инициировать запрос к серверу для сохранения изменений.
*   Клиентское приложение должно работать с актуальными данными, полученными с сервера.

**2.4.2. Целостность данных**
*   Каждая задача должна иметь на сервере уникальный идентификатор, присваиваемый при создании.
*   Сервер является единственным источником истины для состояния приложения.

**2.4.3. Обработка конфликтов и ошибок**
*   В случае ошибки сети или сервера при выполнении операции (например, сохранении новой задачи) система должна уведомить пользователя о невозможности выполнить действие.
*   Система должна предпринимать попытки повтора неудачных операций или предоставлять пользователю возможность повторить действие.

---

### 3. Заключение

Данный документ описывает базовый функционал веб-сервиса для управления задачами. Все требования являются функциональными и не накладывают ограничений на выбор технологий для реализации клиентской и серверной частей, за исключением обязательного требования о постоянном хранении данных на сервере и их синхронизации с клиентским интерфейсом.
`.

**Структура:**

- **Functional Requirements**: Список FR1, FR2, ... с описанием каждой функции

- **Non-Functional Requirements**: NFR1 (Performance), NFR2 (Security), NFR3 (Scalability) с конкретными метриками

#### 2.3. `DOCS/AI/Execution_Guide/03_Technical_Spec.md`

Архитектура и технические детали. Используй `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x` и `backend/src/Domain/UseCases (бизнес-логика для управления задачами),
backend/src/Domain/Models (сущности Task, User),
backend/src/Infrastructure/Repositories (репозитории для работы с БД),
backend/src/Infrastructure/Http/Controllers (API контроллеры),
frontend/src/components/TodoList (компонент списка задач),
frontend/src/components/TodoItem (компонент отдельной задачи),
frontend/src/services/api (сервис для работы с backend API)`.

**Структура:**

- **Architecture**: Описание компонентов и их взаимодействия

- **Data Contracts**: API сигнатуры, структуры данных

- **Component Responsibilities**: Что делает каждый компонент

- **Technology Stack Details**: Версии, зависимости, инструменты

#### 2.4. `DOCS/AI/Execution_Guide/04_TODO_Workplan.md`

**ВАЖНО**: Сгенерируй начальный план работ на основе `**Техническое задание на разработку веб-сервиса управления задачами (Todo Service)**

---

### 1. Введение

#### 1.1. Назначение документа
Настоящий документ содержит функциональные требования к веб-сервису для управления персональным списком задач (заметками, "todo"). Сервис должен быть доступен через веб-браузер и обеспечивать синхронизацию данных между различными устройствами пользователя за счет хранения всех операций на сервере.

#### 1.2. Описание продукта
Данный сервис представляет собой одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. Все изменения должны немедленно сохраняться на сервере. Основной упор делается на простоту, надежность и отзывчивость интерфейса.

---

### 2. Функциональные требования

#### 2.1. Управление задачами

**2.1.1. Создание новой задачи**
*   **Триггер:** Пользователь вводит текст в поле ввода и нажимает клавишу `Enter`.
*   **Требования:**
    *   Система должна создать новую задачу с введенным текстом.
    *   Новая задача по умолчанию получает статус "не выполнена" (`active`).
    *   Задача должна быть немедленно сохранена на сервере.
    *   Поле ввода должно быть очищено после создания задачи.

**2.1.2. Просмотр списка задач**
*   **Триггер:** Открытие приложения или выполнение любой операции, изменяющей список.
*   **Требования:**
    *   Система должна отображать список всех задач пользователя.
    *   Для каждой задачи должен отображаться ее текст и текущий статус.
    *   Список должен автоматически обновляться при любых изменениях (создание, редактирование, удаление, изменение статуса).

**2.1.3. Редактирование текста задачи**
*   **Триггер:** Пользователь дважды кликает по тексту существующей задачи.
*   **Требования:**
    *   Система должна перевести поле текста задачи в режим редактирования.
    *   Пользователь должен иметь возможность изменить текст.
    *   При нажатии клавиши `Enter` или потере полем фокуса (`blur`) система должна сохранить изменения на сервере и выйти из режима редактирования.
    *   При нажатии клавиши `Escape` система должна отменить редактирование, восстановив исходный текст, без сохранения на сервере.

**2.1.4. Изменение статуса задачи (выполнено/не выполнено)**
*   **Триггер:** Пользователь кликает на чекбокс слева от задачи.
*   **Требования:**
    *   При клике на чекбокс у невыполненной задачи система должна изменить ее статус на "выполнена" (`completed`).
    *   При клике на чекбокс у выполненной задачи система должна изменить ее статус на "не выполнена" (`active`).
    *   Изменение статуса должно быть немедленно сохранено на сервере.
    *   Визуальное отображение задачи (например, перечеркнутый текст) должно изменяться в соответствии с ее статусом.

**2.1.5. Удаление одной задачи**
*   **Триггер:** Пользователь наводит курсор на задачу и нажимает на кнопку "Удалить" (обычно значок `×`), которая появляется при наведении.
*   **Требования:**
    *   Система должна удалить соответствующую задачу.
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Задача должна быть удалена из интерфейса.

**2.1.6. Удаление всех выполненных задач**
*   **Триггер:** Пользователь нажимает на кнопку "Clear completed" ("Очистить выполненные").
*   **Требования:**
    *   Система должна удалить все задачи со статусом "выполнена" (`completed`).
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Соответствующие задачи должны быть удалены из интерфейса.

#### 2.2. Фильтрация и отображение

**2.2.1. Переключение между фильтрами**
*   **Триггер:** Пользователь кликает на один из элементов управления для фильтрации: "All", "Active", "Completed".
*   **Требования:**
    *   **All:** Система отображает все задачи (и `active`, и `completed`).
    *   **Active:** Система отображает только задачи со статусом "не выполнена" (`active`).
    *   **Completed:** Система отображает только задачи со статусом "выполнена" (`completed`).
    *   Сами задачи на сервере не изменяются. Фильтрация происходит на стороне клиента на основе актуальных данных, полученных с сервера.

#### 2.3. Вспомогательная информация

**2.3.1. Отображение количества невыполненных задач**
*   **Триггер:** Любое изменение в списке задач.
*   **Требования:**
    *   Система должна отображать текущее количество невыполненных задач (`active`).
    *   Текст должен быть в формате, например: "`<n> items left`" ("`<n> задач осталось`").

#### 2.4. Требования к данным и синхронизации

**2.4.1. Сохранение состояния на сервере**
*   Все операции, изменяющие данные (создание, редактирование текста, изменение статуса, удаление), должны немедленно инициировать запрос к серверу для сохранения изменений.
*   Клиентское приложение должно работать с актуальными данными, полученными с сервера.

**2.4.2. Целостность данных**
*   Каждая задача должна иметь на сервере уникальный идентификатор, присваиваемый при создании.
*   Сервер является единственным источником истины для состояния приложения.

**2.4.3. Обработка конфликтов и ошибок**
*   В случае ошибки сети или сервера при выполнении операции (например, сохранении новой задачи) система должна уведомить пользователя о невозможности выполнить действие.
*   Система должна предпринимать попытки повтора неудачных операций или предоставлять пользователю возможность повторить действие.

---

### 3. Заключение

Данный документ описывает базовый функционал веб-сервиса для управления задачами. Все требования являются функциональными и не накладывают ограничений на выбор технологий для реализации клиентской и серверной частей, за исключением обязательного требования о постоянном хранении данных на сервере и их синхронизации с клиентским интерфейсом.
`. Разбей ТЗ на 5-10 высокоуровневых задач (например, "Настроить проект", "Реализовать аутентификацию", "Создать модели данных", "Настроить CI/CD").

**Структура:**

Каждая задача должна быть представлена в виде таблицы со следующими полями:

| Task ID | Description | Priority | Effort (days) | Dependencies | Tools | Acceptance Criteria |
| --- | --- | --- | --- | --- | --- | --- |
| A1 | Инициализировать проект | High | 1 | None | [инструменты из стека] | Проект собирается успешно |
| A2 | Настроить CI пайплайн | High | 1.5 | A1 | GitHub Actions | CI запускается на PR |
| ... | ... | ... | ... | ... | ... | ... |

**Фазы**: Организуй задачи в фазы (Phase A — Foundations, Phase B — Core Features, Phase C — Integration, и т.д.)

**Индикаторы статуса**:

- **Completed ✅**: Задача завершена и заархивирована

- **In Progress**: В процессе выполнения (документирована в `DOCS/INPROGRESS/`)

- **Blocked**: Невозможно продолжить из-за внешних зависимостей

- **Open**: Готова к началу (зависимости удовлетворены)

---

### ШАГ 3: Создай базовые файлы проекта

#### 3.1. `.gitignore`

Сгенерируй соответствующий `.gitignore` для `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x`. Включи стандартные игнорируемые файлы для указанных языков и инструментов.

****Примеры**:
- Python: `__pycache__/`, `*.pyc`, `.env`, `venv/`
- Node.js: `node_modules/`, `dist/`, `.env`
- Go: `*.exe`, `*.test`, `vendor/`
- Swift: `.build/`, `*.xcodeproj/`, `DerivedData/`
- PHP: `vendor/`, `.env`, `*.log`, `storage/logs/`, `bootstrap/cache/`

#### 3.2. `README.md`

Создай файл с `CoolTodo`, `Веб-сервис для управления персональным списком задач (заметками, "todo"). 
Одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. 
Все изменения немедленно сохраняются на сервере для синхронизации между устройствами.` и секцией "Getting Started".

**Структура:**

```markdown
# CoolTodo

Веб-сервис для управления персональным списком задач (заметками, "todo"). 
Одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. 
Все изменения немедленно сохраняются на сервере для синхронизации между устройствами.

## Technology Stack

PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x

## Getting Started

### Prerequisites

- [Список необходимых инструментов и версий]

### Installation

```bash
[Команды для установки зависимостей]
```

### Running the Project

```bash
[Команды для запуска проекта]
```

### Running Tests

```bash
[Команды для запуска тестов]
```

## Project Structure

```
[Описание структуры директорий]
```

## Documentation

See `DOCS/` for detailed documentation and AI agent guidelines.

```

#### 3.3. `.github/workflows/ci.yml`

Создай базовый CI-пайплайн для GitHub Actions. Он должен включать шаги для сборки (`build`) и тестирования (`test`), адаптированные под `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x`.

**Общая структура:**
```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: [выбери: ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup [язык/инструмент]
        [шаги для настройки окружения]
      
      - name: Install dependencies
        run: [команда установки зависимостей]
      
      - name: Build
        run: [команда сборки]
      
      - name: Test
        run: [команда запуска тестов]
      
      - name: Check coverage
        run: [команда проверки покрытия, если применимо]
```

#### 3.4. `Dockerfile` (если Docker указан в стеке)

Создай базовый Dockerfile для запуска проекта. Адаптируй под `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x`.

**Общая структура:**

```
FROM [базовый образ для языка/фреймворка]

WORKDIR /app

COPY [файлы зависимостей] .
RUN [команда установки зависимостей]

COPY . .

RUN [команда сборки, если нужна]

EXPOSE [порт]

CMD [команда запуска приложения]
```

#### 3.5. `docker-compose.yml` (если Docker указан в стеке и есть несколько сервисов)

Создай `docker-compose.yml` для оркестрации сервисов (например, приложение + база данных).

---

### ШАГ 4: Создай структуру исходного кода

#### 4.1. Структура директорий

Создай папки для исходного кода на основе `backend/src/Domain/UseCases (бизнес-логика для управления задачами),
backend/src/Domain/Models (сущности Task, User),
backend/src/Infrastructure/Repositories (репозитории для работы с БД),
backend/src/Infrastructure/Http/Controllers (API контроллеры),
frontend/src/components/TodoList (компонент списка задач),
frontend/src/components/TodoItem (компонент отдельной задачи),
frontend/src/services/api (сервис для работы с backend API)` и лучших практик для `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x`.

**Примеры**:

- Python/Django: `backend/users/`, `backend/tasks/`, `frontend/src/`

- Node.js: `src/services/`, `src/controllers/`, `src/models/`

- Go: `cmd/`, `internal/`, `pkg/`

- Swift: `Sources/[ProjectName]Kit/`, `Sources/[ProjectName]CLI/`, `Tests/`

- PHP/Laravel: `app/Models/`, `app/Http/Controllers/`, `app/Services/`, `routes/`, `database/migrations/`

- PHP (vanilla): `src/`, `public/`, `config/`, `tests/`

#### 4.2. Файлы-заглушки

Внутри каждой основной директории компонента создай файл-заглушку с минимальным кодом "Hello, World!" или базовой структурой.

**Примеры**:

- Python: `main.py` с `print("Hello, World!")`

- JavaScript: `index.js` с `console.log("Hello, World!");`

- Go: `main.go` с `package main; func main() { fmt.Println("Hello, World!") }`

- Swift: `main.swift` с `print("Hello, World!")`

- PHP: `index.php` с `<?php echo "Hello, World!"; ?>`

#### 4.3. Первый тест (TDD)

Создай директорию `tests/` (или аналогичную для `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x`) и добавь один простой, **заведомо провальный** тест, который проверяет базовую функциональность из `**Техническое задание на разработку веб-сервиса управления задачами (Todo Service)**

---

### 1. Введение

#### 1.1. Назначение документа
Настоящий документ содержит функциональные требования к веб-сервису для управления персональным списком задач (заметками, "todo"). Сервис должен быть доступен через веб-браузер и обеспечивать синхронизацию данных между различными устройствами пользователя за счет хранения всех операций на сервере.

#### 1.2. Описание продукта
Данный сервис представляет собой одностраничное веб-приложение (SPA), позволяющее пользователю создавать, просматривать, редактировать и удалять задачи. Все изменения должны немедленно сохраняться на сервере. Основной упор делается на простоту, надежность и отзывчивость интерфейса.

---

### 2. Функциональные требования

#### 2.1. Управление задачами

**2.1.1. Создание новой задачи**
*   **Триггер:** Пользователь вводит текст в поле ввода и нажимает клавишу `Enter`.
*   **Требования:**
    *   Система должна создать новую задачу с введенным текстом.
    *   Новая задача по умолчанию получает статус "не выполнена" (`active`).
    *   Задача должна быть немедленно сохранена на сервере.
    *   Поле ввода должно быть очищено после создания задачи.

**2.1.2. Просмотр списка задач**
*   **Триггер:** Открытие приложения или выполнение любой операции, изменяющей список.
*   **Требования:**
    *   Система должна отображать список всех задач пользователя.
    *   Для каждой задачи должен отображаться ее текст и текущий статус.
    *   Список должен автоматически обновляться при любых изменениях (создание, редактирование, удаление, изменение статуса).

**2.1.3. Редактирование текста задачи**
*   **Триггер:** Пользователь дважды кликает по тексту существующей задачи.
*   **Требования:**
    *   Система должна перевести поле текста задачи в режим редактирования.
    *   Пользователь должен иметь возможность изменить текст.
    *   При нажатии клавиши `Enter` или потере полем фокуса (`blur`) система должна сохранить изменения на сервере и выйти из режима редактирования.
    *   При нажатии клавиши `Escape` система должна отменить редактирование, восстановив исходный текст, без сохранения на сервере.

**2.1.4. Изменение статуса задачи (выполнено/не выполнено)**
*   **Триггер:** Пользователь кликает на чекбокс слева от задачи.
*   **Требования:**
    *   При клике на чекбокс у невыполненной задачи система должна изменить ее статус на "выполнена" (`completed`).
    *   При клике на чекбокс у выполненной задачи система должна изменить ее статус на "не выполнена" (`active`).
    *   Изменение статуса должно быть немедленно сохранено на сервере.
    *   Визуальное отображение задачи (например, перечеркнутый текст) должно изменяться в соответствии с ее статусом.

**2.1.5. Удаление одной задачи**
*   **Триггер:** Пользователь наводит курсор на задачу и нажимает на кнопку "Удалить" (обычно значок `×`), которая появляется при наведении.
*   **Требования:**
    *   Система должна удалить соответствующую задачу.
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Задача должна быть удалена из интерфейса.

**2.1.6. Удаление всех выполненных задач**
*   **Триггер:** Пользователь нажимает на кнопку "Clear completed" ("Очистить выполненные").
*   **Требования:**
    *   Система должна удалить все задачи со статусом "выполнена" (`completed`).
    *   Удаление должно быть немедленно сохранено на сервере.
    *   Соответствующие задачи должны быть удалены из интерфейса.

#### 2.2. Фильтрация и отображение

**2.2.1. Переключение между фильтрами**
*   **Триггер:** Пользователь кликает на один из элементов управления для фильтрации: "All", "Active", "Completed".
*   **Требования:**
    *   **All:** Система отображает все задачи (и `active`, и `completed`).
    *   **Active:** Система отображает только задачи со статусом "не выполнена" (`active`).
    *   **Completed:** Система отображает только задачи со статусом "выполнена" (`completed`).
    *   Сами задачи на сервере не изменяются. Фильтрация происходит на стороне клиента на основе актуальных данных, полученных с сервера.

#### 2.3. Вспомогательная информация

**2.3.1. Отображение количества невыполненных задач**
*   **Триггер:** Любое изменение в списке задач.
*   **Требования:**
    *   Система должна отображать текущее количество невыполненных задач (`active`).
    *   Текст должен быть в формате, например: "`<n> items left`" ("`<n> задач осталось`").

#### 2.4. Требования к данным и синхронизации

**2.4.1. Сохранение состояния на сервере**
*   Все операции, изменяющие данные (создание, редактирование текста, изменение статуса, удаление), должны немедленно инициировать запрос к серверу для сохранения изменений.
*   Клиентское приложение должно работать с актуальными данными, полученными с сервера.

**2.4.2. Целостность данных**
*   Каждая задача должна иметь на сервере уникальный идентификатор, присваиваемый при создании.
*   Сервер является единственным источником истины для состояния приложения.

**2.4.3. Обработка конфликтов и ошибок**
*   В случае ошибки сети или сервера при выполнении операции (например, сохранении новой задачи) система должна уведомить пользователя о невозможности выполнить действие.
*   Система должна предпринимать попытки повтора неудачных операций или предоставлять пользователю возможность повторить действие.

---

### 3. Заключение

Данный документ описывает базовый функционал веб-сервиса для управления задачами. Все требования являются функциональными и не накладывают ограничений на выбор технологий для реализации клиентской и серверной частей, за исключением обязательного требования о постоянном хранении данных на сервере и их синхронизации с клиентским интерфейсом.
`.

**Цель**: Этот failing test станет отправной точкой для TDD-цикла ИИ-агента.

**Примеры**:

- Python (pytest):

   ```python
   def test_user_creation():
       # This test will fail until User model is implemented
       user = User(username="test", email="test@example.com")
       assert user.username == "test"
   ```

- JavaScript (Jest):

   ```javascript
   test('creates a task', () => {
     // This test will fail until Task class is implemented
     const task = new Task('Write tests');
     expect(task.title).toBe('Write tests');
   });
   ```

- Go:

   ```go
   func TestUserCreation(t *testing.T) {
       // This test will fail until User struct is implemented
       user := User{Username: "test"}
       if user.Username != "test" {
           t.Errorf("Expected username 'test', got '%s'", user.Username)
       }
   }
   ```

- PHP (PHPUnit):

   ```php
   <?php
   use PHPUnit\Framework\TestCase;
   
   class UserTest extends TestCase
   {
       public function testUserCreation()
       {
           // This test will fail until User class is implemented
           $user = new User('test', 'test@example.com');
           $this->assertEquals('test', $user->getUsername());
       }
   }
   ```

---

### ШАГ 5: Создай дополнительные файлы для автоматизации

#### 5.1. `DOCS/INPROGRESS/next_tasks.md`

Создай файл для отслеживания очереди задач:

```markdown
# Next Tasks Queue

## Ready to Start

- [ ] Task A1: [описание]
- [ ] Task A2: [описание]

## In Progress

- [ ] Task A3: [описание] (assigned to AI agent on 2025-11-26)

## Blocked

- [ ] Task B1: [описание] (waiting for external API access)
```

#### 5.2. `DOCS/INPROGRESS/blocked.md`

Создай файл для отслеживания заблокированных задач:

```markdown
# Blocked Tasks

| Task ID | Description | Blocker | Expected Resolution |
|---------|-------------|---------|---------------------|
| B1 | Integrate payment API | Waiting for API keys | 2025-12-01 |
```

#### 5.3. `.githooks/pre-commit` (опционально)

Создай pre-commit hook для автоматической проверки кода перед коммитом:

```bash
#!/bin/bash
set -e

# Format code
[команда форматирования для языка]

# Lint
[команда линтинга]

# Run quick tests
[команда быстрых тестов]

echo "✅ Pre-commit checks passed"
```

---

## ФОРМАТ ВЫВОДА

Предоставь результат в виде **полного списка файлов с их содержимым**. Каждый файл должен быть представлен в следующем формате:

```
## Файл: /path/to/file.ext

```язык
Полное содержимое файла...
```

```

**Порядок вывода:**
1. Документация (`DOCS/RULES/`, `DOCS/AI/`)
2. Конфигурационные файлы (`.gitignore`, `README.md`, `ci.yml`, `Dockerfile`)
3. Структура исходного кода (директории и файлы-заглушки)
4. Тесты
5. Дополнительные файлы (`INPROGRESS/`, `.githooks/`)

---

## КРИТЕРИИ КАЧЕСТВА

Убедись, что сгенерированный каркас соответствует следующим критериям:

1. **Самодостаточность**: ИИ-агент может начать работу без дополнительных вопросов
2. **Однозначность**: Все инструкции четкие и не допускают интерпретаций
3. **Машиночитаемость**: Документация структурирована (таблицы, списки, четкие секции)
4. **Технологическая адекватность**: Все файлы адаптированы под `PHP 8.3, Laravel 11.x, MySQL 8.0/8.4, Vue 3.5, Vite 7.2, Docker, PHPUnit 11.x, Laravel Dusk 8.x, 
PHPStan 2.x (level 9), PHP-CS-Fixer 3.x, Xdebug 3.x`
5. **TDD-готовность**: Есть failing test для начала TDD-цикла
6. **CI/CD-готовность**: CI пайплайн настроен и готов к запуску
7. **Полнота**: Включены все необходимые компоненты из `backend/src/Domain/UseCases (бизнес-логика для управления задачами),
backend/src/Domain/Models (сущности Task, User),
backend/src/Infrastructure/Repositories (репозитории для работы с БД),
backend/src/Infrastructure/Http/Controllers (API контроллеры),
frontend/src/components/TodoList (компонент списка задач),
frontend/src/components/TodoItem (компонент отдельной задачи),
frontend/src/services/api (сервис для работы с backend API)`

---

## НАЧАЛО РАБОТЫ

После генерации каркаса пользователь должен:

1. Создать все файлы в локальной системе или репозитории
2. Инициализировать git репозиторий: `git init`
3. Сделать первый коммит: `git commit -m "chore: initialize project structure for AI agent development"`
4. Создать репозиторий на GitHub и запушить код
5. Подключить ИИ-агента (GitHub Copilot Agent или другой)
6. Создать первый issue на основе задачи A1 из `TODO_Workplan.md` и назначить на агента

---

**ТЕПЕРЬ СГЕНЕРИРУЙ КАРКАС ПРОЕКТА НА ОСНОВЕ ПРЕДОСТАВЛЕННЫХ ВХОДНЫХ ДАННЫХ.**
```

68e34b55edc67102c21a785b808a2459c31df79c



---

## ПРИЛОЖЕНИЕ: Требования к Архитектуре

---

### **Требования к Архитектуре Приложения CoolTodo**

**Версия документа:** 1.1
**Дата актуализации:** 2025-11-29

---

### **1. Технологический Стек (Backend)**

**1.1. Язык и Фреймворк:**
*   **Язык программирования:** PHP 8.3 (текущая стабильная версия 8.3.28, поддержка до декабря 2025, затем рекомендуется переход на PHP 8.4).
*   **Фреймворк:** Laravel 11.x (текущая версия 11.47.0, стабильная актуальная версия).

**1.2. База данных:**
*   **Основная СУБД:** MySQL 8.0 (текущая версия 8.0.45) или MySQL 8.4 LTS (рекомендуется для долгосрочной поддержки).
*   **Драйвер:** `pdo_mysql`.
*   **Требование:** Все миграции должны быть обратимыми.

**1.3. Очереди:**
*   **Драйвер по умолчанию:** `database` (хранение заданий в таблице БД).
*   **Требование:** Архитектура должна допускать замену драйвера очередей (например, на Redis, Amazon SQS) без изменений в бизнес-логике. Конфигурация должна быть вынесена в environment variables.

---

### **2. Принципы Разработки и Качество Кода**

**2.1. The Twelve-Factor App:**
Код должен строго следовать всем 12 принципам, с особым вниманием к:
*   **I. Кодовая база:** Одна кодовая база, отслеживаемая в системе контроля версий, множество развертываний.
*   **III. Настройки:** Все настройки (ключи, endpoints, credentials) должны храниться в environment variables (`.env` файл) и быть доступны через `config/services.php`.
*   **V. Сборка, релиз, выполнение:** Четкое разделение стадий сборки и выполнения.
*   **VI. Процессы:** Приложение выполняется как один или несколько stateless-процессов.
*   **VIII. Конкурентность:** Масштабирование через процессы (через механизм очередей Laravel).
*   **XI. Журналирование:** Логи рассматриваются как потоки событий.

**2.2. Типизация и Статический Анализ:**
*   **Строгая типизация:** Весь PHP-код должен использовать строгий режим (`declare(strict_types=1)`).
*   **Подробные аннотации:** Использование PHPDoc для всех классов, методов, свойств и сложных структур данных с целью максимального покрытия для статического анализатора.
*   **Статический анализ:**
    *   **Инструмент:** PHPStan (текущая версия 2.x).
    *   **Уровень:** Максимальный (`level: 9`).
    *   **Правила для Laravel:** Использовать пакет `larastan/larastan` с максимально строгими настройками.
    *   **Интеграция в CI:** Анализ должен быть обязательным шагом в пайплайне.

**2.3. Стайлинг и Анализ Качества:**
*   **Инструмент проверки стиля:** PHP Code Sniffer (PHPCS) с стандартом кодирования PSR-12.
*   **Инструмент автоматического исправления:** PHP Coding Standards Fixer (PHP-CS-Fixer, текущая версия 3.x).
*   **Анализ мертвого кода:** PHPMD с включенным правилом `codesize`, `unusedcode`, `design`, `naming`, `cleancode`.
*   **Требование:** В CI/CD пайплайн должны быть встроены шаги с автофиксом (через PHP-CS-Fixer) и проверкой (PHPCS, PHPMD, PHPStan).

---

### **3. Архитектура Приложения**

**3.1. Архитектурный Слой:**
*   **Принцип:** Четкое разделение на бизнес-логику и инфраструктурный слой.
*   **Бизнес-слой (Domain Layer):**
    *   Содержит Use Cases (Сценарии использования), Domain Models (Сущности), Value Objects, Domain Services.
    *   Не должен зависеть от фреймворка (Laravel) или внешних сервисов (БД, API, кеш).
*   **Инфраструктурный Слой (Infrastructure Layer):**
    *   Реализует интерфейсы, объявленные в бизнес-слое (репозитории, клиенты API, сервисы уведомлений).
    *   Использует возможности фреймворка (Eloquent ORM, HTTP-клиент, Почта).

**3.2. Use Case Architecture:**
*   Каждая бизнес-операция инкапсулирована в отдельном классе Use Case.
*   Use Cases координируют поток данных между сущностями и внешними интерфейсами.
*   Они являются основой для модульного тестирования.

---

### **4. Фронтенд**

*   **Тип приложения:** Single Page Application (SPA).
*   **Фреймворк:** Vue 3.x (текущая версия 3.5.x, Composition API, стабильная актуальная версия).
*   **Связь с Backend:** Через RESTful API (с обязательным документированием).
*   **Сборка:** Vite (текущая версия 7.2.x).

---

### **5. Внешние Сервисы и Интеграции**

**5.1. Нейросеть для распознавания данных:**
*   **Провайдер по умолчанию:** Коммерческий API DeepSeek.
*   **Требование:** Реализация через `Http`-клиент Laravel, инкапсулирована в инфраструктурном сервисе, реализующем интерфейс из бизнес-слоя. Конфигурация (URL, ключ) должна быть вынесена в environment variables для легкой замены провайдера.

**5.2. Хранение файлов:**
*   **Версия 1.0:** Файловая система (локальное хранилище). Драйвер `local`.
*   **Требование:** Использовать Filesystem Abstraction Laravel. Архитектура должна допускать бесшовную замену на облачное хранилище (например, `s3` от Selectel) через смену драйвера в конфигурации.
*   **Драйвер по умолчанию:** `local`.

**5.3. Отправка E-mail:**
*   **Протокол:** SMTP.
*   **Библиотека:** Стандартный `Mail` фасад Laravel.
*   **Требование:** Все настройки SMTP-сервера должны быть вынесены в environment variables.

**5.4. Логирование:**
*   **Версия 1.0:** Логирование в файлы. Использовать стандартный канал `stack` Laravel с направлением в `daily`-файлы.
*   **Будущая версия:** Интеграция с GlitchTip. Архитектура должна допускать замену канала логирования через конфигурацию `config/logging.php`.
*   **Контент логов:**
    *   Уровень: `debug`.
    *   Обязательно логировать: все входящие HTTP-запросы и исходящие HTTP-ответы, входящие и исходящие данные для внешних API, результаты работы ключевых функций системы (начало/конец обработки Use Case).

---

### **6. Тестирование**

**6.1. Модульные тесты (Unit Tests):**
*   **Покрытие:** Бизнес-слой (Use Cases, Domain Models, Services) должен быть покрыт юнит-тестами на >90%.
*   **Инструмент:** PHPUnit (текущая версия 11.x).
*   **Подход:** Использование моков и стабов для изоляции бизнес-логики от инфраструктуры.

**6.2. Интеграционные тесты (Integration Tests):**
*   **Покрытие:** Все публичные API endpoints.
*   **Инструмент:** PHPUnit + `Laravel` `TestCase`.
*   **Объем:** Тестирование взаимодействия с БД, очередями, файловой системой.

**6.3. Функциональные тесты (Functional / E2E Tests):**
*   **Покрытие:** Все ключевые пользовательские сценарии (User Journeys).
*   **Инструмент:** Laravel Dusk (текущая версия 8.x).
*   **Режим:** Headless-браузер (например, Chrome в headless-режиме).

---

### **7. Деплой и Окружения**

**7.1. Контейнеризация:**
*   **Инструмент:** Docker + Docker Compose.
*   **Требование:** Должны быть представлены конфигурации для `prod` и `dev` окружений.
    *   **`docker-compose.yml`:** Базовая конфигурация для production-подобного окружения.
    *   **`docker-compose.override.yml`:** Конфигурация для локальной разработки (dev).

**7.2. Локальное окружение (dev):**
*   **Отладка:** Обязательно наличие и корректная настройка Xdebug 3.x.
*   **Перезагрузка кода:** Использование Volumes для синхронизации кода с хост-машиной.

**7.3. Production окружение:**
*   **Требования к производительности:**
    *   **Нагрузка:** Выдерживать пиковую нагрузку в **100 RPS** (запросов в секунду).
    *   **Ресурсы:** Ограничение по железу: **2 vCPU, 8 ГБ RAM**.
    *   **Время ответа:** Время обработки одного документа (от получения до финального ответа клиенту) не должно превышать **1 минуту**. Долгосрочные задачи должны выполняться асинхронно через очереди.
*   **Оптимизация:**
    *   OPCache должен быть включен и корректно настроен.
    *   Автозагрузчик Composer должен быть оптимизирован (`--optimize-autoloader --classmap-authoritative`).
    *   Конфигурация Laravel должна быть закэширована (`config:cache`, `route:cache`, `event:cache`, `view:cache`).

---

### **Резюме и Контрольные Точки**

1.  **Стек:** PHP 8.3 + Laravel 11 + MySQL 8.0/8.4 + Vue 3.5 + Vite 7.
2.  **Архитектура:** 12-Factor, Clean Architecture с Use Cases, разделение на Domain и Infrastructure слои.
3.  **Качество кода:** Максимальный уровень PHPStan, строгая типизация, PSR-12, автофиксеры в CI.
4.  **Сервисы:** DeepSeek (с заменой), Локальное ФС -> S3, Логи в файлы -> GlitchTip, Очереди в БД (с заменой).
5.  **Тесты:** Юниты для бизнес-логики, Интеграционные для API, Функциональные (Dusk) для E2E.
6.  **Окружения:** Docker Compose с разделением на prod/dev, Xdebug 3 в dev.
7.  **Производительность:** 100 RPS на 2 CPU / 8 GB RAM.

